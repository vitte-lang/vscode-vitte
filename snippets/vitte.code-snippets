{
  "main": {
    "prefix": "main",
    "body": [
      "do main() {",
      "  print(\"Hello, Vitte!\")",
      "}"
    ],
    "description": "Entrée programme"
  },
  "module_doc": {
    "prefix": "mod-doc",
    "body": [
      "//! ${1:Nom du module} — ${2:description courte}",
      "//! Invariants: ${3:liste}",
      ""
    ],
    "description": "Bannière de doc de module"
  },
  "function": {
    "prefix": "do",
    "body": [
      "do ${1:name}(${2:args})${3: -> ${4:T}} {",
      "  ${0:// TODO}",
      "}"
    ],
    "description": "Définition de fonction"
  },
  "function_result": {
    "prefix": "dor",
    "body": [
      "do ${1:name}(${2:args}) -> Result[${3:T}, ${4:E}] {",
      "  ${0:// ...}",
      "}"
    ],
    "description": "Fonction retournant un Result"
  },
  "async_function": {
    "prefix": "async",
    "body": [
      "async do ${1:name}(${2:args}) -> ${3:T} {",
      "  ${0:// await ...}",
      "}"
    ],
    "description": "Fonction async (preview)"
  },
  "struct": {
    "prefix": "struct",
    "body": [
      "struct ${1:Type} {",
      "  ${2:field}: ${3:T}",
      "}"
    ],
    "description": "Structure"
  },
  "enum": {
    "prefix": "enum",
    "body": [
      "enum ${1:Enum} {",
      "  ${2:Variant1},",
      "  ${3:Variant2(${4:T})}",
      "}"
    ],
    "description": "Énumération"
  },
  "trait": {
    "prefix": "trait",
    "body": [
      "trait ${1:Trait} {",
      "  do ${2:method}(self &)${3: -> ${4:T}};",
      "}"
    ],
    "description": "Trait (interface)"
  },
  "impl": {
    "prefix": "impl",
    "body": [
      "impl ${1:Type} {",
      "  do ${2:new}() -> ${1:Type} { ${1:Type}{} }",
      "}"
    ],
    "description": "Impl bloc"
  },
  "type_alias_result": {
    "prefix": "type-result",
    "body": [
      "enum ${1:AppError} { Io(str), Parse(str), Net(str) }",
      "type ${2:AppResult}[T] = Result[T, ${1:AppError}]"
    ],
    "description": "Alias Result + enum d’erreurs"
  },
  "match_exhaustif": {
    "prefix": "matchx",
    "body": [
      "match ${1:expr} {",
      "  ${2:Enum::A} => ${3:handle_a()},",
      "  ${4:Enum::B(x)} => ${5:handle_b(x)},",
      "  _ => ${6:default()},",
      "}"
    ],
    "description": "Pattern matching exhaustif"
  },
  "option_usage": {
    "prefix": "opt",
    "body": [
      "let ${1:val} = ${2:opt}.unwrap_or(${3:default})"
    ],
    "description": "Option.unwrap_or"
  },
  "result_map": {
    "prefix": "res-map",
    "body": [
      "${1:res}.map(|x| ${2:transform}(x)).map_err(|e| ${3:log::error}(e))"
    ],
    "description": "Result.map / map_err"
  },
  "assert": {
    "prefix": "assert",
    "body": [
      "assert(${1:cond}, \"${2:message}\")"
    ],
    "description": "Assertion"
  },
  "cli_parse": {
    "prefix": "cli",
    "body": [
      "use cli",
      "",
      "do main() -> i32 {",
      "  let args = cli::parse()",
      "  if cli::has(args, \"--help\") {",
      "    print(\"Usage: app --name <N>\")",
      "    return 0",
      "  }",
      "  let name = cli::get(args, \"--name\").unwrap_or(\"world\")",
      "  print(\"Hello, \" + name)",
      "  0",
      "}"
    ],
    "description": "Parsing d’arguments (CLI)"
  },
  "config_load": {
    "prefix": "config",
    "body": [
      "use config",
      "",
      "do load_cfg(path: str) -> Result[Map[str,str], str] {",
      "  config::load(path)",
      "}"
    ],
    "description": "Chargement configuration"
  },
  "validate_input": {
    "prefix": "validate",
    "body": [
      "use validate",
      "",
      "do validate_user(name: str) -> Result[Unit, str] {",
      "  if validate::len_range(name, 3, 64) && validate::is_alnum(name) {",
      "    Ok(())",
      "  } else {",
      "    Err(\"invalid user name\")",
      "  }",
      "}"
    ],
    "description": "Validation d’entrée"
  },
  "fs_read_write": {
    "prefix": "fs-rw",
    "body": [
      "use fs",
      "",
      "do rw(path: str) -> Result[String, FsError] {",
      "  fs::write(path, string::to_bytes(\"data\"))?",
      "  fs::read_to_string(path)",
      "}"
    ],
    "description": "Fichier: read/write"
  },
  "fs_atomic_write": {
    "prefix": "fs-atomic",
    "body": [
      "use fs; use fs_atomic",
      "",
      "do save_atomic(p: str, data: []u8) -> Result[Unit, FsError] {",
      "  fs::create_dir_all(string::dirname(p))?",
      "  fs_atomic::write(p, data)?",
      "  Ok(())",
      "}"
    ],
    "description": "Écriture atomique de fichier"
  },
  "process_spawn": {
    "prefix": "proc",
    "body": [
      "use process",
      "",
      "do run_ls() -> Result[i32, str] {",
      "  process::spawn(\"ls\", [\"-la\"]).map_err(|e| to_string(e))",
      "}"
    ],
    "description": "Lancer un processus (preview)"
  },
  "time_sleep": {
    "prefix": "sleep",
    "body": [
      "use time",
      "",
      "do wait_ms(ms: u32) {",
      "  time::sleep(ms.ms)",
      "}"
    ],
    "description": "Temporisation"
  },
  "http_get": {
    "prefix": "http-get",
    "body": [
      "use http_client; use string",
      "",
      "do fetch(url: str) -> Result[String, HttpError] {",
      "  let r = http_client::get(url)?",
      "  Ok(string::from_bytes(r.body))",
      "}"
    ],
    "description": "HTTP GET (sync)"
  },
  "http_post": {
    "prefix": "http-post",
    "body": [
      "use http_client; use string",
      "",
      "do post_json(url: str, body: String) -> Result[u16, HttpError] {",
      "  let headers = Map[str,str]{",
      "    \"Content-Type\": \"application/json\"",
      "  }",
      "  let r = http_client::post(url, string::to_bytes(body), headers)?",
      "  Ok(r.status)",
      "}"
    ],
    "description": "HTTP POST JSON"
  },
  "retry_policy": {
    "prefix": "retry",
    "body": [
      "use retry",
      "",
      "do with_retry[T](op: () -> Result[T, str]) -> Result[T, str] {",
      "  let p = retry::exponential_backoff(max_retries: 5, base_ms: 80, jitter: true)",
      "  retry::run(p, op)",
      "}"
    ],
    "description": "Backoff exponentiel + jitter"
  },
  "rate_limiter": {
    "prefix": "rate",
    "body": [
      "use rate_limiter",
      "",
      "do guarded() -> bool {",
      "  let rl = rate_limiter::token_bucket(capacity: 10, refill_per_sec: 5)",
      "  rl.try_acquire(1)",
      "}"
    ],
    "description": "Rate limiter token-bucket"
  },
  "channel_threads": {
    "prefix": "chan-threads",
    "body": [
      "use thread; use channel",
      "",
      "do sum_parallel(xs: Vec[i32]) -> i64 {",
      "  let (tx, rx) = channel::channel",
      "  let mid = xs.len() / 2",
      "  let left = thread::spawn({",
      "    let mut s = 0",
      "    for x in xs[0..mid] { s += x as i64 }",
      "    tx.send(s)",
      "  })",
      "  let right = thread::spawn({",
      "    let mut s = 0",
      "    for x in xs[mid..] { s += x as i64 }",
      "    tx.send(s)",
      "  })",
      "  let a = rx.recv().unwrap()",
      "  let b = rx.recv().unwrap()",
      "  left.join(); right.join()",
      "  a + b",
      "}"
    ],
    "description": "Concurrence: threads + channel"
  },
  "channel_try": {
    "prefix": "chan-try",
    "body": [
      "use channel",
      "",
      "do drain_non_blocking[T](rx: Receiver[T]) -> Vec[T] {",
      "  let mut out = Vec[T]{}",
      "  loop {",
      "    match rx.try_recv() {",
      "      Ok(v) => out.push(v),",
      "      Err(_) => break",
      "    }",
      "  }",
      "  out",
      "}"
    ],
    "description": "Channel non bloquant (try_recv)"
  },
  "taskpool_spawn": {
    "prefix": "taskpool",
    "body": [
      "use taskpool",
      "",
      "do parallel_map(xs: Vec[i32]) -> Vec[i32] {",
      "  let p = taskpool::with_threads(4)",
      "  for x in xs {",
      "    p.spawn({",
      "      let _y = x * x",
      "    })",
      "  }",
      "  p.join_all()",
      "  xs",
      "}"
    ],
    "description": "Taskpool simple"
  },
  "scheduler_cron": {
    "prefix": "scheduler",
    "body": [
      "use scheduler",
      "",
      "do plan() {",
      "  scheduler::every(\"*/5 * * * *\", || {",
      "    print(\"tick\")",
      "  })",
      "}"
    ],
    "description": "Tâches périodiques (cron-like)"
  },
  "log_usage": {
    "prefix": "log",
    "body": [
      "use log",
      "",
      "do main(){",
      "  log::info(\"starting\")",
      "  log::debug(\"details: \" + to_string(42))",
      "  log::error(\"oops\")",
      "}"
    ],
    "description": "Logging multi-niveaux"
  },
  "metrics_usage": {
    "prefix": "metrics",
    "body": [
      "use metrics",
      "",
      "do record(){",
      "  let c = metrics::counter(\"requests_total\")",
      "  c.inc(1)",
      "  let g = metrics::gauge(\"in_flight\")",
      "  g.set(3)",
      "}"
    ],
    "description": "Compteurs/jauges (preview)"
  },
  "tracing_span": {
    "prefix": "trace",
    "body": [
      "use tracing",
      "",
      "do work(){",
      "  let sp = tracing::span(\"work\", { req_id: \"${1:id}\" })",
      "  sp.enter()",
      "  // ...",
      "  sp.exit()",
      "}"
    ],
    "description": "Tracing spans (preview)"
  },
  "pagination": {
    "prefix": "paginate",
    "body": [
      "use pagination",
      "",
      "do page(xs: Vec[i32], limit: usize, cursor: String?) -> (Vec[i32], String?) {",
      "  pagination::cursor(xs, limit, cursor)",
      "}"
    ],
    "description": "Pagination (offset/cursor)"
  },
  "uuid_random": {
    "prefix": "uuid",
    "body": [
      "use uuid",
      "",
      "let ${1:id} = uuid::v4()"
    ],
    "description": "UUID v4"
  },
  "uuid_v7": {
    "prefix": "uuid7",
    "body": [
      "use uuid; use time; use random",
      "",
      "let now = time::now_ms()",
      "let rnd = random::bytes(10)",
      "let ${1:id} = uuid::v7(now, rnd)"
    ],
    "description": "UUID v7 (time-ordered, preview)"
  },
  "idgen_snowflake": {
    "prefix": "idgen",
    "body": [
      "use idgen",
      "",
      "let gen = idgen::new(node_id: 1)",
      "let ${1:id} = gen.next()"
    ],
    "description": "Générateur d’IDs (preview)"
  },
  "random_range": {
    "prefix": "rand",
    "body": [
      "use random",
      "",
      "let ${1:x} = random::rand_range(0, 100)"
    ],
    "description": "Nombre aléatoire dans un intervalle"
  },
  "stringx_utils": {
    "prefix": "stringx",
    "body": [
      "use stringx",
      "",
      "let ${1:slug} = stringx::slugify(${2:title})",
      "let ${3:upper} = stringx::case_convert(${4:s}, \"upper\")"
    ],
    "description": "Utilitaires de chaînes"
  },
  "mathx_utils": {
    "prefix": "mathx",
    "body": [
      "use mathx",
      "",
      "let ${1:g} = mathx::gcd(24, 36)",
      "let ${2:l} = mathx::lcm(12, 18)",
      "let ${3:y} = mathx::lerp(0.0, 10.0, 0.25)"
    ],
    "description": "Utilitaires math"
  },
  "csv_parse": {
    "prefix": "csv",
    "body": [
      "use csv",
      "",
      "do parse_csv(data: String) -> Vec[Vec[String]] {",
      "  csv::read(string::to_bytes(data))",
      "}"
    ],
    "description": "Parsing CSV"
  },
  "ini_parse": {
    "prefix": "ini",
    "body": [
      "use ini",
      "",
      "let ${1:cfg} = ini::parse(\"[db]\\nport=5432\\n\")"
    ],
    "description": "Parsing INI"
  },
  "yaml_lite_parse": {
    "prefix": "yaml",
    "body": [
      "use yaml_lite",
      "",
      "let ${1:doc} = yaml_lite::parse(\"key: value\")"
    ],
    "description": "Parsing YAML lite"
  },
  "checksum_crc32": {
    "prefix": "crc32",
    "body": [
      "use checksum",
      "",
      "let ${1:h} = checksum::crc32(${2:bytes})"
    ],
    "description": "CRC32"
  },
  "rle_encode_decode": {
    "prefix": "rle",
    "body": [
      "use rle",
      "",
      "let ${1:enc} = rle::encode(${2:bytes})",
      "let ${3:dec} = rle::decode(${1:enc})"
    ],
    "description": "Run-Length Encoding"
  },
  "vec_reserve": {
    "prefix": "vec-reserve",
    "body": [
      "let mut ${1:v} = Vec[${2:T}]{}",
      "${1:v}.reserve(${3:capacity})"
    ],
    "description": "Pré-allouer un Vec"
  },
  "map_set": {
    "prefix": "mapset",
    "body": [
      "let mut ${1:m} = Map[${2:K}, ${3:V}]{}",
      "let mut ${4:s} = Set[${5:T}]{}"
    ],
    "description": "Collections Map/Set"
  },
  "graph_bfs": {
    "prefix": "graph-bfs",
    "body": [
      "use graph",
      "",
      "do bfs(g: graph::Graph, src: usize) -> Vec[usize] {",
      "  graph::bfs(g, src)",
      "}"
    ],
    "description": "BFS (graph)"
  },
  "pool_reuse": {
    "prefix": "pool",
    "body": [
      "use pool",
      "",
      "let ${1:p} = pool::with_capacity"
    ],
    "description": "Pool d’objets"
  },
  "prioq_usage": {
    "prefix": "prioq",
    "body": [
      "use prioq",
      "",
      "let mut ${1:q} = prioq::new[i32]()",
      "${1:q}.push(10)",
      "let ${2:top} = ${1:q}.pop()"
    ],
    "description": "File à priorité"
  },
  "kvstore_ttl": {
    "prefix": "kvstore",
    "body": [
      "use kvstore",
      "",
      "let ${1:db} = kvstore::open(\"/tmp/kv\")",
      "${1:db}.put(\"key\", string::to_bytes(\"value\"), ttl_ms: 60000)",
      "let ${2:v} = ${1:db}.get(\"key\")"
    ],
    "description": "Key-Value store avec TTL"
  },
  "cache_lru": {
    "prefix": "cache",
    "body": [
      "use cache",
      "",
      "let mut ${1:c} = cache::lru_with_capacity",
      "${1:c}.put(${4:k}, ${5:v})",
      "let ${6:hit} = ${1:c}.get(&${4:k})"
    ],
    "description": "Cache LRU"
  },
  "migrate_step": {
    "prefix": "migrate",
    "body": [
      "use migrate",
      "",
      "do up(conn &: any) -> Result[Unit, str] {",
      "  migrate::exec(conn, \"CREATE TABLE example(id INT)\")",
      "}",
      "",
      "do down(conn &: any) -> Result[Unit, str] {",
      "  migrate::exec(conn, \"DROP TABLE example\")",
      "}"
    ],
    "description": "Migration up/down"
  },
  "supervisor_tree": {
    "prefix": "supervisor",
    "body": [
      "use supervisor",
      "",
      "do start_tree() {",
      "  let sup = supervisor::new()",
      "  sup.child(\"worker1\", || { /* ... */ })",
      "  sup.child(\"worker2\", || { /* ... */ })",
      "  sup.run()",
      "}"
    ],
    "description": "Arbre de supervision"
  },
  "eventbus_pubsub": {
    "prefix": "eventbus",
    "body": [
      "use eventbus",
      "",
      "do demo(){",
      "  let bus = eventbus::new()",
      "  bus.subscribe(\"user.*\", |ev| { print(\"got: \" + ev.topic) })",
      "  bus.publish(\"user.created\", string::to_bytes(\"alice\"))",
      "}"
    ],
    "description": "Pub/Sub en mémoire"
  },
  "feature_flags": {
    "prefix": "flags",
    "body": [
      "use feature_flags",
      "",
      "let ${1:flags} = feature_flags::from_env()",
      "if ${1:flags}.is_enabled(\"new-ui\") {",
      "  ${2:enable_new_ui()}",
      "} else {",
      "  ${3:enable_old_ui()}",
      "}"
    ],
    "description": "Feature flags"
  },
  "ffi_extern": {
    "prefix": "externc",
    "body": [
      "extern(c) do ${1:c_func}(${2:args}) -> ${3:i32}"
    ],
    "description": "Déclaration FFI C"
  },
  "ffi_ptr_len": {
    "prefix": "ffi-pl",
    "body": [
      "extern(c) do ${1:hash32}(data: ?*u8, len: usize, out: *u32) -> i32",
      "",
      "do compute(buf: []u8) -> Result[u32, i32] {",
      "  let mut h: u32 = 0",
      "  let code = ${1:hash32}(buf.ptr(), buf.len(), &mut h)",
      "  if code==0 { Ok(h) } else { Err(code) }",
      "}"
    ],
    "description": "FFI pattern pointeur+longueur"
  },
  "test_unit": {
    "prefix": "test",
    "body": [
      "@test",
      "do ${1:should_do_something}() {",
      "  ${0:assert(1+1==2, \"math broke\")} ",
      "}"
    ],
    "description": "Test unitaire (attribut @test)"
  }
}
